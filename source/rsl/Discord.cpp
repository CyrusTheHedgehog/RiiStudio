#include "Discord.hpp"

#include <cassert>
#include <optional>

// TODO: Link to autogenerated version
#include "FFIActivity.hh"

#include "Log.hpp"

extern "C" {

struct C_RPC;

C_RPC* rsl_rpc_create(const char* application_id);
void rsl_rpc_destroy(C_RPC*);

// 0 -> OK, negative -> error
int rsl_rpc_connect(C_RPC*);
// Only valid if prior connect call succeeded
void rsl_rpc_disconnect(C_RPC*);
// Sets a status. Type of ffi::Activity from FFIActivity.hh
void rsl_rpc_set_activity(C_RPC*, void* activity);
// Sets dummy status
void rsl_rpc_test(C_RPC*);
}

namespace rsl {

using DISCORD_DELETER = decltype([](::C_RPC* x) { rsl_rpc_destroy(x); });
using rpc_pointer = std::unique_ptr<::C_RPC, DISCORD_DELETER>;

class DiscordIpcClient::Impl {
private:
  Impl(::C_RPC& ptr) : m_handle(&ptr) {}

public:
  static std::optional<Impl> create(const char* application_id) {
    ::C_RPC* ptr = rsl_rpc_create(application_id);
    if (ptr == nullptr) {
      return std::nullopt;
    }
    return Impl(*ptr);
  }
  Impl(const Impl&) = delete;
  Impl(Impl&& rhs) = default;
  ~Impl() = default;

  ::C_RPC& handle() { return *m_handle; }

private:
  rpc_pointer m_handle;

public:
  bool m_connected = false;
};

DiscordIpcClient::DiscordIpcClient(std::string_view application_id) {
  auto s = std::string(application_id);
  auto h = Impl::create(s.c_str());
  if (h.has_value()) {
    m_impl = std::make_unique<Impl>(std::move(*h));
  }
}
DiscordIpcClient::DiscordIpcClient(DiscordIpcClient&& rhs) {
  m_impl = std::move(rhs.m_impl);
}
DiscordIpcClient::~DiscordIpcClient() {
  if (m_impl && m_impl->m_connected) {
    disconnect();
  }
}
bool DiscordIpcClient::connect() {
  if (m_impl == nullptr) {
    rsl::warn("[rsl::DiscordIpcClient] connect() failed. No socket");
    return false;
  }
  if (m_impl->m_connected) {
    // Already connected
    rsl::warn("[rsl::DiscordIpcClient] connect() - Already connected");
    return true;
  }
  const int err = rsl_rpc_connect(&m_impl->handle());
  if (err != 0) {
    return false;
  }
  m_impl->m_connected = true;
  return true;
}
bool DiscordIpcClient::connected() const {
  return m_impl != nullptr && m_impl->m_connected;
}
void DiscordIpcClient::disconnect() {
  if (m_impl != nullptr && m_impl->m_connected) {
    rsl_rpc_disconnect(&m_impl->handle());
    m_impl->m_connected = false;
  }
}
void DiscordIpcClient::set_activity(const Activity& activity) {
  if (m_impl == nullptr) {
    rsl::error("[rsl::DiscordIpcClient] set_activity failed. No socket exists");
    return;
  }
  if (!m_impl->m_connected) {
    rsl::error("[rsl::DiscordIpcClient] set_activity failed. Not connected to "
               "Discord");
    return;
  }
  ffi::Activity a{
      .state = activity.state,
      .details = activity.details,
      .timestamps =
          {
              .start = activity.timestamps.start,
              .end = activity.timestamps.end,
          },
  };
  a.buttons.clear();
  for (auto& x : activity.buttons) {
    a.buttons.push_back(ffi::Button{
        .text = x.text,
        .link = x.link,
    });
  }
  a.assets = ffi::Asset{
      .large_image = activity.assets.large_image,
      .large_text = activity.assets.large_text,
  };
  rsl_rpc_set_activity(&m_impl->handle(), &a);
}
void DiscordIpcClient::test() {
  if (m_impl != nullptr) {
    rsl_rpc_test(&m_impl->handle());
  }
}

} // namespace rsl
